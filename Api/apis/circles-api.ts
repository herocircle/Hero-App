/* tslint:disable */
/* eslint-disable */
/**
 * hero-circle-api
 * The Hero Circle API description
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { ActionProposal } from '../models';
import { Circle } from '../models';
import { CircleStatisticsDto } from '../models';
import { CircleSupportersResponseDTO } from '../models';
import { GetUserSkillQueryResponse } from '../models';
import { NewPositionsDto } from '../models';
import { OmitTypeClass } from '../models';
import { PublicCircleProfileDTO } from '../models';
/**
 * CirclesApi - axios parameter creator
 * @export
 */
export const CirclesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {boolean} main 
         * @param {boolean} global 
         * @param {boolean} isActive 
         * @param {string} user 
         * @param {string} urlName 
         * @param {string} name 
         * @param {string} goal 
         * @param {number} subscriptionGoal 
         * @param {string} description 
         * @param {string} type 
         * @param {Blob} avatar 
         * @param {Blob} cover 
         * @param {Blob} video 
         * @param {boolean} isPayoutEnabled 
         * @param {Array<string>} supporters 
         * @param {Array<string>} mobilizers 
         * @param {number} activeCampaigners 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCircleForm: async (main: boolean, global: boolean, isActive: boolean, user: string, urlName: string, name: string, goal: string, subscriptionGoal: number, description: string, type: string, avatar: Blob, cover: Blob, video: Blob, isPayoutEnabled: boolean, supporters: Array<string>, mobilizers: Array<string>, activeCampaigners: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'main' is not null or undefined
            if (main === null || main === undefined) {
                throw new RequiredError('main','Required parameter main was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'global' is not null or undefined
            if (global === null || global === undefined) {
                throw new RequiredError('global','Required parameter global was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'isActive' is not null or undefined
            if (isActive === null || isActive === undefined) {
                throw new RequiredError('isActive','Required parameter isActive was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'urlName' is not null or undefined
            if (urlName === null || urlName === undefined) {
                throw new RequiredError('urlName','Required parameter urlName was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'goal' is not null or undefined
            if (goal === null || goal === undefined) {
                throw new RequiredError('goal','Required parameter goal was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'subscriptionGoal' is not null or undefined
            if (subscriptionGoal === null || subscriptionGoal === undefined) {
                throw new RequiredError('subscriptionGoal','Required parameter subscriptionGoal was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'avatar' is not null or undefined
            if (avatar === null || avatar === undefined) {
                throw new RequiredError('avatar','Required parameter avatar was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'cover' is not null or undefined
            if (cover === null || cover === undefined) {
                throw new RequiredError('cover','Required parameter cover was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'video' is not null or undefined
            if (video === null || video === undefined) {
                throw new RequiredError('video','Required parameter video was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'isPayoutEnabled' is not null or undefined
            if (isPayoutEnabled === null || isPayoutEnabled === undefined) {
                throw new RequiredError('isPayoutEnabled','Required parameter isPayoutEnabled was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'supporters' is not null or undefined
            if (supporters === null || supporters === undefined) {
                throw new RequiredError('supporters','Required parameter supporters was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'mobilizers' is not null or undefined
            if (mobilizers === null || mobilizers === undefined) {
                throw new RequiredError('mobilizers','Required parameter mobilizers was null or undefined when calling createCircleForm.');
            }
            // verify required parameter 'activeCampaigners' is not null or undefined
            if (activeCampaigners === null || activeCampaigners === undefined) {
                throw new RequiredError('activeCampaigners','Required parameter activeCampaigners was null or undefined when calling createCircleForm.');
            }
            const localVarPath = `/circles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (main !== undefined) { 
                localVarFormParams.append('main', main as any);
            }

            if (global !== undefined) { 
                localVarFormParams.append('global', global as any);
            }

            if (isActive !== undefined) { 
                localVarFormParams.append('isActive', isActive as any);
            }

            if (user !== undefined) { 
                localVarFormParams.append('_user', user as any);
            }

            if (urlName !== undefined) { 
                localVarFormParams.append('url_name', urlName as any);
            }

            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }

            if (goal !== undefined) { 
                localVarFormParams.append('goal', goal as any);
            }

            if (subscriptionGoal !== undefined) { 
                localVarFormParams.append('subscriptionGoal', subscriptionGoal as any);
            }

            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }

            if (type !== undefined) { 
                localVarFormParams.append('_type', type as any);
            }

            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', avatar as any);
            }

            if (cover !== undefined) { 
                localVarFormParams.append('cover', cover as any);
            }

            if (video !== undefined) { 
                localVarFormParams.append('video', video as any);
            }

            if (isPayoutEnabled !== undefined) { 
                localVarFormParams.append('isPayoutEnabled', isPayoutEnabled as any);
            }
            if (supporters) {
                supporters.forEach((element) => {
                    localVarFormParams.append('_supporters', element as any);
                })
            }
            if (mobilizers) {
                mobilizers.forEach((element) => {
                    localVarFormParams.append('_mobilizers', element as any);
                })
            }

            if (activeCampaigners !== undefined) { 
                localVarFormParams.append('activeCampaigners', activeCampaigners as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCircle: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCircle.');
            }
            const localVarPath = `/circles/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrphanedMobilizers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/circles/orphaned-mobilizers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrphanedSupporters: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/circles/orphaned-supporters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCircle: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCircle.');
            }
            const localVarPath = `/circles/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCircleFullMobilizers: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCircleFullMobilizers.');
            }
            const localVarPath = `/circles/mobilizers/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} urlName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCircleIdByUrlName: async (urlName: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'urlName' is not null or undefined
            if (urlName === null || urlName === undefined) {
                throw new RequiredError('urlName','Required parameter urlName was null or undefined when calling getCircleIdByUrlName.');
            }
            const localVarPath = `/circles/by-url/{url_name}`
                .replace(`{${"url_name"}}`, encodeURIComponent(String(urlName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCircleMobilizers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/circles/mobilizers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCircleProfile: async (slug: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            if (slug === null || slug === undefined) {
                throw new RequiredError('slug','Required parameter slug was null or undefined when calling getCircleProfile.');
            }
            const localVarPath = `/circles/{slug}/profile`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCircleStats: async (slug: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'slug' is not null or undefined
            if (slug === null || slug === undefined) {
                throw new RequiredError('slug','Required parameter slug was null or undefined when calling getCircleStats.');
            }
            const localVarPath = `/circles/{slug}/stats`
                .replace(`{${"slug"}}`, encodeURIComponent(String(slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCircleSupporters: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getCircleSupporters.');
            }
            const localVarPath = `/circles/supporters/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} [main] 
         * @param {boolean} [global] 
         * @param {boolean} [all] If true, will also get inactive circles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCircles: async (main?: boolean, global?: boolean, all?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/circles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (main !== undefined) {
                localVarQueryParameter['main'] = main;
            }

            if (global !== undefined) {
                localVarQueryParameter['global'] = global;
            }

            if (all !== undefined) {
                localVarQueryParameter['all'] = all;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMainCircle: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/circles/main`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrphanedMobilizers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/circles/orphaned-mobilizers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrphanedSupporters: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/circles/orphaned-supporters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserSkillTypes: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/circles/user/skills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary (Re)set indices of all documents in the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetIndices: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/circles/reset-indices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OmitTypeClass} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitSkillProposal: async (body: OmitTypeClass, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling submitSkillProposal.');
            }
            const localVarPath = `/circles/proposal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers!['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<Blob>} avatar 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAvatarForm: async (avatar: Array<Blob>, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'avatar' is not null or undefined
            if (avatar === null || avatar === undefined) {
                throw new RequiredError('avatar','Required parameter avatar was null or undefined when calling updateAvatarForm.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAvatarForm.');
            }
            const localVarPath = `/circles/{_id}/avatar`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (avatar) {
                avatar.forEach((element) => {
                    localVarFormParams.append('avatar', element as any);
                })
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {boolean} main 
         * @param {boolean} global 
         * @param {boolean} isActive 
         * @param {string} user 
         * @param {string} urlName 
         * @param {string} name 
         * @param {string} goal 
         * @param {number} subscriptionGoal 
         * @param {string} description 
         * @param {string} type 
         * @param {Blob} avatar 
         * @param {Blob} cover 
         * @param {Blob} video 
         * @param {boolean} isPayoutEnabled 
         * @param {string} id2 
         * @param {Array<string>} supporters 
         * @param {Array<string>} mobilizers 
         * @param {number} activeCampaigners 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCircleForm: async (main: boolean, global: boolean, isActive: boolean, user: string, urlName: string, name: string, goal: string, subscriptionGoal: number, description: string, type: string, avatar: Blob, cover: Blob, video: Blob, isPayoutEnabled: boolean, id2: string, supporters: Array<string>, mobilizers: Array<string>, activeCampaigners: number, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'main' is not null or undefined
            if (main === null || main === undefined) {
                throw new RequiredError('main','Required parameter main was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'global' is not null or undefined
            if (global === null || global === undefined) {
                throw new RequiredError('global','Required parameter global was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'isActive' is not null or undefined
            if (isActive === null || isActive === undefined) {
                throw new RequiredError('isActive','Required parameter isActive was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'user' is not null or undefined
            if (user === null || user === undefined) {
                throw new RequiredError('user','Required parameter user was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'urlName' is not null or undefined
            if (urlName === null || urlName === undefined) {
                throw new RequiredError('urlName','Required parameter urlName was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'goal' is not null or undefined
            if (goal === null || goal === undefined) {
                throw new RequiredError('goal','Required parameter goal was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'subscriptionGoal' is not null or undefined
            if (subscriptionGoal === null || subscriptionGoal === undefined) {
                throw new RequiredError('subscriptionGoal','Required parameter subscriptionGoal was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'avatar' is not null or undefined
            if (avatar === null || avatar === undefined) {
                throw new RequiredError('avatar','Required parameter avatar was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'cover' is not null or undefined
            if (cover === null || cover === undefined) {
                throw new RequiredError('cover','Required parameter cover was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'video' is not null or undefined
            if (video === null || video === undefined) {
                throw new RequiredError('video','Required parameter video was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'isPayoutEnabled' is not null or undefined
            if (isPayoutEnabled === null || isPayoutEnabled === undefined) {
                throw new RequiredError('isPayoutEnabled','Required parameter isPayoutEnabled was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'id2' is not null or undefined
            if (id2 === null || id2 === undefined) {
                throw new RequiredError('id2','Required parameter id2 was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'supporters' is not null or undefined
            if (supporters === null || supporters === undefined) {
                throw new RequiredError('supporters','Required parameter supporters was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'mobilizers' is not null or undefined
            if (mobilizers === null || mobilizers === undefined) {
                throw new RequiredError('mobilizers','Required parameter mobilizers was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'activeCampaigners' is not null or undefined
            if (activeCampaigners === null || activeCampaigners === undefined) {
                throw new RequiredError('activeCampaigners','Required parameter activeCampaigners was null or undefined when calling updateCircleForm.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCircleForm.');
            }
            const localVarPath = `/circles/{_id}`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication bearer required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? await configuration.accessToken()
                    : await configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


            if (main !== undefined) { 
                localVarFormParams.append('main', main as any);
            }

            if (global !== undefined) { 
                localVarFormParams.append('global', global as any);
            }

            if (isActive !== undefined) { 
                localVarFormParams.append('isActive', isActive as any);
            }

            if (user !== undefined) { 
                localVarFormParams.append('_user', user as any);
            }

            if (urlName !== undefined) { 
                localVarFormParams.append('url_name', urlName as any);
            }

            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }

            if (goal !== undefined) { 
                localVarFormParams.append('goal', goal as any);
            }

            if (subscriptionGoal !== undefined) { 
                localVarFormParams.append('subscriptionGoal', subscriptionGoal as any);
            }

            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }

            if (type !== undefined) { 
                localVarFormParams.append('_type', type as any);
            }

            if (avatar !== undefined) { 
                localVarFormParams.append('avatar', avatar as any);
            }

            if (cover !== undefined) { 
                localVarFormParams.append('cover', cover as any);
            }

            if (video !== undefined) { 
                localVarFormParams.append('video', video as any);
            }

            if (isPayoutEnabled !== undefined) { 
                localVarFormParams.append('isPayoutEnabled', isPayoutEnabled as any);
            }

            if (id !== undefined) { 
                localVarFormParams.append('_id', id as any);
            }
            if (supporters) {
                supporters.forEach((element) => {
                    localVarFormParams.append('_supporters', element as any);
                })
            }
            if (mobilizers) {
                mobilizers.forEach((element) => {
                    localVarFormParams.append('_mobilizers', element as any);
                })
            }

            if (activeCampaigners !== undefined) { 
                localVarFormParams.append('activeCampaigners', activeCampaigners as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<Blob>} cover 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCoverForm: async (cover: Array<Blob>, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cover' is not null or undefined
            if (cover === null || cover === undefined) {
                throw new RequiredError('cover','Required parameter cover was null or undefined when calling updateCoverForm.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCoverForm.');
            }
            const localVarPath = `/circles/{_id}/cover`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (cover) {
                cover.forEach((element) => {
                    localVarFormParams.append('cover', element as any);
                })
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Takes an array of document IDs and uses their positions for reordering documents
         * @param {NewPositionsDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateIndices: async (body: NewPositionsDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateIndices.');
            }
            const localVarPath = `/circles/update-indices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers!['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<Blob>} video 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVideoForm: async (video: Array<Blob>, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'video' is not null or undefined
            if (video === null || video === undefined) {
                throw new RequiredError('video','Required parameter video was null or undefined when calling updateVideoForm.');
            }
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateVideoForm.');
            }
            const localVarPath = `/circles/{_id}/video`
                .replace(`{${"_id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            if (video) {
                video.forEach((element) => {
                    localVarFormParams.append('video', element as any);
                })
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CirclesApi - functional programming interface
 * @export
 */
export const CirclesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {boolean} main 
         * @param {boolean} global 
         * @param {boolean} isActive 
         * @param {string} user 
         * @param {string} urlName 
         * @param {string} name 
         * @param {string} goal 
         * @param {number} subscriptionGoal 
         * @param {string} description 
         * @param {string} type 
         * @param {Blob} avatar 
         * @param {Blob} cover 
         * @param {Blob} video 
         * @param {boolean} isPayoutEnabled 
         * @param {Array<string>} supporters 
         * @param {Array<string>} mobilizers 
         * @param {number} activeCampaigners 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCircleForm(main: boolean, global: boolean, isActive: boolean, user: string, urlName: string, name: string, goal: string, subscriptionGoal: number, description: string, type: string, avatar: Blob, cover: Blob, video: Blob, isPayoutEnabled: boolean, supporters: Array<string>, mobilizers: Array<string>, activeCampaigners: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Circle>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).createCircleForm(main, global, isActive, user, urlName, name, goal, subscriptionGoal, description, type, avatar, cover, video, isPayoutEnabled, supporters, mobilizers, activeCampaigners, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCircle(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).deleteCircle(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrphanedMobilizers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).deleteOrphanedMobilizers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrphanedSupporters(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).deleteOrphanedSupporters(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircle(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Circle>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getCircle(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleFullMobilizers(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getCircleFullMobilizers(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} urlName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleIdByUrlName(urlName: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getCircleIdByUrlName(urlName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleMobilizers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Circle>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getCircleMobilizers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleProfile(slug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PublicCircleProfileDTO>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getCircleProfile(slug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleStats(slug: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<CircleStatisticsDto>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getCircleStats(slug, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleSupporters(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<CircleSupportersResponseDTO>>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getCircleSupporters(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} [main] 
         * @param {boolean} [global] 
         * @param {boolean} [all] If true, will also get inactive circles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircles(main?: boolean, global?: boolean, all?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<Circle>>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getCircles(main, global, all, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMainCircle(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Circle>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getMainCircle(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrphanedMobilizers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getOrphanedMobilizers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrphanedSupporters(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<any>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getOrphanedSupporters(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSkillTypes(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<GetUserSkillQueryResponse>>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).getUserSkillTypes(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary (Re)set indices of all documents in the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetIndices(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).resetIndices(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {OmitTypeClass} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSkillProposal(body: OmitTypeClass, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ActionProposal>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).submitSkillProposal(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Array<Blob>} avatar 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAvatarForm(avatar: Array<Blob>, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Circle>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).updateAvatarForm(avatar, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {boolean} main 
         * @param {boolean} global 
         * @param {boolean} isActive 
         * @param {string} user 
         * @param {string} urlName 
         * @param {string} name 
         * @param {string} goal 
         * @param {number} subscriptionGoal 
         * @param {string} description 
         * @param {string} type 
         * @param {Blob} avatar 
         * @param {Blob} cover 
         * @param {Blob} video 
         * @param {boolean} isPayoutEnabled 
         * @param {string} id2 
         * @param {Array<string>} supporters 
         * @param {Array<string>} mobilizers 
         * @param {number} activeCampaigners 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCircleForm(main: boolean, global: boolean, isActive: boolean, user: string, urlName: string, name: string, goal: string, subscriptionGoal: number, description: string, type: string, avatar: Blob, cover: Blob, video: Blob, isPayoutEnabled: boolean, id2: string, supporters: Array<string>, mobilizers: Array<string>, activeCampaigners: number, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Circle>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).updateCircleForm(main, global, isActive, user, urlName, name, goal, subscriptionGoal, description, type, avatar, cover, video, isPayoutEnabled, id2, supporters, mobilizers, activeCampaigners, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Array<Blob>} cover 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCoverForm(cover: Array<Blob>, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Circle>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).updateCoverForm(cover, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary Takes an array of document IDs and uses their positions for reordering documents
         * @param {NewPositionsDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIndices(body: NewPositionsDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).updateIndices(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {Array<Blob>} video 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVideoForm(video: Array<Blob>, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Circle>>> {
            const localVarAxiosArgs = await CirclesApiAxiosParamCreator(configuration).updateVideoForm(video, id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CirclesApi - factory interface
 * @export
 */
export const CirclesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {boolean} main 
         * @param {boolean} global 
         * @param {boolean} isActive 
         * @param {string} user 
         * @param {string} urlName 
         * @param {string} name 
         * @param {string} goal 
         * @param {number} subscriptionGoal 
         * @param {string} description 
         * @param {string} type 
         * @param {Blob} avatar 
         * @param {Blob} cover 
         * @param {Blob} video 
         * @param {boolean} isPayoutEnabled 
         * @param {Array<string>} supporters 
         * @param {Array<string>} mobilizers 
         * @param {number} activeCampaigners 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCircleForm(main: boolean, global: boolean, isActive: boolean, user: string, urlName: string, name: string, goal: string, subscriptionGoal: number, description: string, type: string, avatar: Blob, cover: Blob, video: Blob, isPayoutEnabled: boolean, supporters: Array<string>, mobilizers: Array<string>, activeCampaigners: number, options?: AxiosRequestConfig): Promise<AxiosResponse<Circle>> {
            return CirclesApiFp(configuration).createCircleForm(main, global, isActive, user, urlName, name, goal, subscriptionGoal, description, type, avatar, cover, video, isPayoutEnabled, supporters, mobilizers, activeCampaigners, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCircle(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return CirclesApiFp(configuration).deleteCircle(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrphanedMobilizers(options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return CirclesApiFp(configuration).deleteOrphanedMobilizers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrphanedSupporters(options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return CirclesApiFp(configuration).deleteOrphanedSupporters(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircle(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Circle>> {
            return CirclesApiFp(configuration).getCircle(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleFullMobilizers(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return CirclesApiFp(configuration).getCircleFullMobilizers(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} urlName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleIdByUrlName(urlName: string, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return CirclesApiFp(configuration).getCircleIdByUrlName(urlName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleMobilizers(options?: AxiosRequestConfig): Promise<AxiosResponse<Circle>> {
            return CirclesApiFp(configuration).getCircleMobilizers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleProfile(slug: string, options?: AxiosRequestConfig): Promise<AxiosResponse<PublicCircleProfileDTO>> {
            return CirclesApiFp(configuration).getCircleProfile(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} slug 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleStats(slug: string, options?: AxiosRequestConfig): Promise<AxiosResponse<CircleStatisticsDto>> {
            return CirclesApiFp(configuration).getCircleStats(slug, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircleSupporters(id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<CircleSupportersResponseDTO>>> {
            return CirclesApiFp(configuration).getCircleSupporters(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} [main] 
         * @param {boolean} [global] 
         * @param {boolean} [all] If true, will also get inactive circles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCircles(main?: boolean, global?: boolean, all?: boolean, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<Circle>>> {
            return CirclesApiFp(configuration).getCircles(main, global, all, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMainCircle(options?: AxiosRequestConfig): Promise<AxiosResponse<Circle>> {
            return CirclesApiFp(configuration).getMainCircle(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrphanedMobilizers(options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return CirclesApiFp(configuration).getOrphanedMobilizers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrphanedSupporters(options?: AxiosRequestConfig): Promise<AxiosResponse<any>> {
            return CirclesApiFp(configuration).getOrphanedSupporters(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserSkillTypes(options?: AxiosRequestConfig): Promise<AxiosResponse<Array<GetUserSkillQueryResponse>>> {
            return CirclesApiFp(configuration).getUserSkillTypes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary (Re)set indices of all documents in the collection
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetIndices(options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return CirclesApiFp(configuration).resetIndices(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OmitTypeClass} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitSkillProposal(body: OmitTypeClass, options?: AxiosRequestConfig): Promise<AxiosResponse<ActionProposal>> {
            return CirclesApiFp(configuration).submitSkillProposal(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<Blob>} avatar 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAvatarForm(avatar: Array<Blob>, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Circle>> {
            return CirclesApiFp(configuration).updateAvatarForm(avatar, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {boolean} main 
         * @param {boolean} global 
         * @param {boolean} isActive 
         * @param {string} user 
         * @param {string} urlName 
         * @param {string} name 
         * @param {string} goal 
         * @param {number} subscriptionGoal 
         * @param {string} description 
         * @param {string} type 
         * @param {Blob} avatar 
         * @param {Blob} cover 
         * @param {Blob} video 
         * @param {boolean} isPayoutEnabled 
         * @param {string} id2 
         * @param {Array<string>} supporters 
         * @param {Array<string>} mobilizers 
         * @param {number} activeCampaigners 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCircleForm(main: boolean, global: boolean, isActive: boolean, user: string, urlName: string, name: string, goal: string, subscriptionGoal: number, description: string, type: string, avatar: Blob, cover: Blob, video: Blob, isPayoutEnabled: boolean, id2: string, supporters: Array<string>, mobilizers: Array<string>, activeCampaigners: number, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Circle>> {
            return CirclesApiFp(configuration).updateCircleForm(main, global, isActive, user, urlName, name, goal, subscriptionGoal, description, type, avatar, cover, video, isPayoutEnabled, id2, supporters, mobilizers, activeCampaigners, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<Blob>} cover 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCoverForm(cover: Array<Blob>, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Circle>> {
            return CirclesApiFp(configuration).updateCoverForm(cover, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Takes an array of document IDs and uses their positions for reordering documents
         * @param {NewPositionsDto} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateIndices(body: NewPositionsDto, options?: AxiosRequestConfig): Promise<AxiosResponse<void>> {
            return CirclesApiFp(configuration).updateIndices(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Array<Blob>} video 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateVideoForm(video: Array<Blob>, id: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Circle>> {
            return CirclesApiFp(configuration).updateVideoForm(video, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CirclesApi - object-oriented interface
 * @export
 * @class CirclesApi
 * @extends {BaseAPI}
 */
export class CirclesApi extends BaseAPI {
    /**
     * 
     * @param {boolean} main 
     * @param {boolean} global 
     * @param {boolean} isActive 
     * @param {string} user 
     * @param {string} urlName 
     * @param {string} name 
     * @param {string} goal 
     * @param {number} subscriptionGoal 
     * @param {string} description 
     * @param {string} type 
     * @param {Blob} avatar 
     * @param {Blob} cover 
     * @param {Blob} video 
     * @param {boolean} isPayoutEnabled 
     * @param {Array<string>} supporters 
     * @param {Array<string>} mobilizers 
     * @param {number} activeCampaigners 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async createCircleForm(main: boolean, global: boolean, isActive: boolean, user: string, urlName: string, name: string, goal: string, subscriptionGoal: number, description: string, type: string, avatar: Blob, cover: Blob, video: Blob, isPayoutEnabled: boolean, supporters: Array<string>, mobilizers: Array<string>, activeCampaigners: number, options?: AxiosRequestConfig) : Promise<AxiosResponse<Circle>> {
        return CirclesApiFp(this.configuration).createCircleForm(main, global, isActive, user, urlName, name, goal, subscriptionGoal, description, type, avatar, cover, video, isPayoutEnabled, supporters, mobilizers, activeCampaigners, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async deleteCircle(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return CirclesApiFp(this.configuration).deleteCircle(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async deleteOrphanedMobilizers(options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return CirclesApiFp(this.configuration).deleteOrphanedMobilizers(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async deleteOrphanedSupporters(options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return CirclesApiFp(this.configuration).deleteOrphanedSupporters(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getCircle(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Circle>> {
        return CirclesApiFp(this.configuration).getCircle(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getCircleFullMobilizers(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return CirclesApiFp(this.configuration).getCircleFullMobilizers(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} urlName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getCircleIdByUrlName(urlName: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return CirclesApiFp(this.configuration).getCircleIdByUrlName(urlName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getCircleMobilizers(options?: AxiosRequestConfig) : Promise<AxiosResponse<Circle>> {
        return CirclesApiFp(this.configuration).getCircleMobilizers(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getCircleProfile(slug: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<PublicCircleProfileDTO>> {
        return CirclesApiFp(this.configuration).getCircleProfile(slug, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} slug 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getCircleStats(slug: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<CircleStatisticsDto>> {
        return CirclesApiFp(this.configuration).getCircleStats(slug, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getCircleSupporters(id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<CircleSupportersResponseDTO>>> {
        return CirclesApiFp(this.configuration).getCircleSupporters(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {boolean} [main] 
     * @param {boolean} [global] 
     * @param {boolean} [all] If true, will also get inactive circles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getCircles(main?: boolean, global?: boolean, all?: boolean, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<Circle>>> {
        return CirclesApiFp(this.configuration).getCircles(main, global, all, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getMainCircle(options?: AxiosRequestConfig) : Promise<AxiosResponse<Circle>> {
        return CirclesApiFp(this.configuration).getMainCircle(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getOrphanedMobilizers(options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return CirclesApiFp(this.configuration).getOrphanedMobilizers(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getOrphanedSupporters(options?: AxiosRequestConfig) : Promise<AxiosResponse<any>> {
        return CirclesApiFp(this.configuration).getOrphanedSupporters(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async getUserSkillTypes(options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<GetUserSkillQueryResponse>>> {
        return CirclesApiFp(this.configuration).getUserSkillTypes(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary (Re)set indices of all documents in the collection
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async resetIndices(options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return CirclesApiFp(this.configuration).resetIndices(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {OmitTypeClass} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async submitSkillProposal(body: OmitTypeClass, options?: AxiosRequestConfig) : Promise<AxiosResponse<ActionProposal>> {
        return CirclesApiFp(this.configuration).submitSkillProposal(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {Array<Blob>} avatar 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async updateAvatarForm(avatar: Array<Blob>, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Circle>> {
        return CirclesApiFp(this.configuration).updateAvatarForm(avatar, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {boolean} main 
     * @param {boolean} global 
     * @param {boolean} isActive 
     * @param {string} user 
     * @param {string} urlName 
     * @param {string} name 
     * @param {string} goal 
     * @param {number} subscriptionGoal 
     * @param {string} description 
     * @param {string} type 
     * @param {Blob} avatar 
     * @param {Blob} cover 
     * @param {Blob} video 
     * @param {boolean} isPayoutEnabled 
     * @param {string} id2 
     * @param {Array<string>} supporters 
     * @param {Array<string>} mobilizers 
     * @param {number} activeCampaigners 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async updateCircleForm(main: boolean, global: boolean, isActive: boolean, user: string, urlName: string, name: string, goal: string, subscriptionGoal: number, description: string, type: string, avatar: Blob, cover: Blob, video: Blob, isPayoutEnabled: boolean, id2: string, supporters: Array<string>, mobilizers: Array<string>, activeCampaigners: number, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Circle>> {
        return CirclesApiFp(this.configuration).updateCircleForm(main, global, isActive, user, urlName, name, goal, subscriptionGoal, description, type, avatar, cover, video, isPayoutEnabled, id2, supporters, mobilizers, activeCampaigners, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {Array<Blob>} cover 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async updateCoverForm(cover: Array<Blob>, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Circle>> {
        return CirclesApiFp(this.configuration).updateCoverForm(cover, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @summary Takes an array of document IDs and uses their positions for reordering documents
     * @param {NewPositionsDto} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async updateIndices(body: NewPositionsDto, options?: AxiosRequestConfig) : Promise<AxiosResponse<void>> {
        return CirclesApiFp(this.configuration).updateIndices(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * 
     * @param {Array<Blob>} video 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CirclesApi
     */
    public async updateVideoForm(video: Array<Blob>, id: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Circle>> {
        return CirclesApiFp(this.configuration).updateVideoForm(video, id, options).then((request) => request(this.axios, this.basePath));
    }
}
